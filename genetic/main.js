// Generated by CoffeeScript 1.10.0
(function() {
  var Alg, Map, Point, Road, Way, alg, canvas, ctx, h, params, randInt, timer, w;

  canvas = document.getElementById("canvas");

  ctx = canvas.getContext("2d");

  w = canvas.width = canvas.clientWidth;

  h = canvas.height = canvas.clientHeight;

  ctx.font = "10px monospace";

  ctx.translate(20, 20);

  randInt = function(min, max) {
    return Math.floor(Math.random() * (max - min) + min);
  };

  params = {
    drawNums: false,
    drawLines: false,
    findLongest: false,
    greenway: true
  };

  Array.prototype.mix = function() {
    var elem, i, index, k, mas, ref, ret;
    mas = this.slice(0);
    ret = [];
    for (i = k = 0, ref = this.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      index = randInt(0, this.length - i - 1);
      elem = mas[index];
      mas.splice(index, 1);
      ret.push(elem);
    }
    return ret;
  };

  Point = (function() {
    function Point(x1, y1) {
      this.x = x1;
      this.y = y1;
      this.roads = [];
    }

    Point.prototype.dist = function(other) {
      return Math.sqrt((this.x - other.x) * (this.x - other.x) + (this.y - other.y) * (this.y - other.y));
    };

    Point.prototype.getSomeRoad = function(to, pref) {
      var nr;
      if (Math.random() < pref) {
        return this.roads[randInt(0, this.roads.length)];
      } else {
        nr = this.roads.sort(function(a, b) {
          return a.to.dist(to) - b.to.dist(to);
        });
        return nr[0];
      }
    };

    Point.prototype.isRoadTo = function(point) {
      var k, len, ref, road;
      ref = this.roads;
      for (k = 0, len = ref.length; k < len; k++) {
        road = ref[k];
        if (road.to === point) {
          return true;
        }
      }
      return false;
    };

    return Point;

  })();

  Road = (function() {
    function Road(from3, to1, speed1) {
      this.from = from3;
      this.to = to1;
      this.speed = speed1;
    }

    Road.prototype.time = function() {
      return (this.from.dist(this.to)) / this.speed;
    };

    Road.prototype.getOther = function(point) {
      if (point === this.from) {
        return this.to;
      } else if (point === this.to) {
        return from;
      } else {
        throw new Error("something bad with ways");
      }
    };

    Road.prototype.eq = function(road) {
      if (road.from === this.from && road.to === this.to || road.from === this.to && road.to === this.from) {
        return true;
      } else {
        return false;
      }
    };

    return Road;

  })();

  Map = (function() {
    function Map(nx, ny, param) {
      var dx, dy, k, len, len1, len2, len3, len4, m, nearest, npoint, o, p, point, q, ref, ref1, ref2, ref3, ref4, ref5, road, road2, s, speed, t, u, way, x, y;
      this.points = [];
      if (ny == null) {
        ny = nx;
      }
      for (x = k = 0, ref = nx; 0 <= ref ? k < ref : k > ref; x = 0 <= ref ? ++k : --k) {
        for (y = m = 0, ref1 = ny; 0 <= ref1 ? m < ref1 : m > ref1; y = 0 <= ref1 ? ++m : --m) {
          if (Math.random() < .2) {
            continue;
          }
          dx = randInt(-5, 5);
          dy = randInt(-5, 5);
          this.points.push(new Point(x * 20 + dx, y * 20 + dy));
        }
      }
      p = this.points.length;
      this.src = this.points[randInt(0, 10)];
      this.dst = this.points[randInt(p - 10, p)];
      ref2 = this.points;
      for (o = 0, len = ref2.length; o < len; o++) {
        point = ref2[o];
        nearest = [];
        ref3 = this.points;
        for (q = 0, len1 = ref3.length; q < len1; q++) {
          npoint = ref3[q];
          if (npoint === point) {
            continue;
          }
          nearest.push(npoint);
          if (nearest.length === 4) {
            nearest = nearest.sort(function(a, b) {
              return a.dist(point) - b.dist(point);
            });
            nearest.pop();
          }
        }
        for (s = 0, len2 = nearest.length; s < len2; s++) {
          npoint = nearest[s];
          if (!(!(npoint.isRoadTo(point)) && !(point.isRoadTo(npoint)))) {
            continue;
          }
          if (param === "greenway") {
            speed = 1;
          } else {
            speed = randInt(1, 255);
          }
          point.roads.push(new Road(point, npoint, speed));
          npoint.roads.push(new Road(npoint, point, speed));
        }
      }
      if (param === "greenway") {
        way = new Way("rand", this, .8);
        ref4 = way.way;
        for (t = 0, len3 = ref4.length; t < len3; t++) {
          road = ref4[t];
          road.speed = 255;
          ref5 = road.to.roads;
          for (u = 0, len4 = ref5.length; u < len4; u++) {
            road2 = ref5[u];
            if (road2.to === road.from) {
              road2.speed = 255;
            }
          }
        }
      }
    }

    Map.prototype.draw = function() {
      var k, len, len1, len2, m, o, point, ref, ref1, ref2, road;
      ctx.fillStyle = "black";
      ctx.fillRect(-20, -20, w, h);
      ctx.strokeStyle = "green";
      ref = this.points;
      for (k = 0, len = ref.length; k < len; k++) {
        point = ref[k];
        ref1 = point.roads;
        for (m = 0, len1 = ref1.length; m < len1; m++) {
          road = ref1[m];
          ctx.beginPath();
          ctx.strokeStyle = "rgb(" + (255 - road.speed) + "," + road.speed + ",0)";
          ctx.moveTo(road.from.x, road.from.y);
          ctx.lineTo(road.to.x, road.to.y);
          ctx.stroke();
        }
      }
      ctx.fillStyle = "blue";
      ref2 = this.points;
      for (o = 0, len2 = ref2.length; o < len2; o++) {
        point = ref2[o];
        ctx.fillRect(point.x - 2, point.y - 2, 3, 3);
      }
      ctx.fillStyle = "white";
      ctx.fillRect(this.src.x - 4, this.src.y - 4, 7, 7);
      ctx.fillStyle = "yellow";
      return ctx.fillRect(this.dst.x - 4, this.dst.y - 4, 7, 7);
    };

    return Map;

  })();

  Way = (function() {
    function Way(type, map, arg1, arg2) {
      this.way = [];
      switch (type) {
        case "rand":
          while (!this.rand(map, arg1)) {}
          break;
        case "cross":
          this.cross(arg1, arg2);
          break;
        case "mutate":
          this.mutate(arg1, arg2);
          break;
        case "empty":
          return;
      }
    }

    Way.prototype.rand = function(map, pref) {
      var a, curr, currroad, f, i, k, len, m, road, way;
      way = [];
      curr = map.src;
      for (i = k = 0; k < 4000; i = ++k) {
        currroad = curr.getSomeRoad(map.dst, pref);
        f = false;
        for (m = 0, len = way.length; m < len; m++) {
          road = way[m];
          if (currroad.to === road.to || currroad.to === road.from) {
            f = true;
          }
        }
        if (f) {
          a = way.pop();
          curr = a.from;
          continue;
        }
        way.push(currroad);
        curr = currroad.to;
        if (curr === map.dst) {
          break;
        }
      }
      if (curr === map.dst) {
        this.way = way;
        return true;
      }
      return false;
    };

    Way.prototype.cross = function(from1, from2) {
      var cross, crossRoads, f, k, len, len1, len2, len3, m, nroad, o, q, ref, ref1, ref2, ref3, ref4, road, way;
      if (from1.eq(from2)) {
        return;
      }
      crossRoads = [];
      ref = from1.way;
      for (k = 0, len = ref.length; k < len; k++) {
        road = ref[k];
        ref1 = from2.way;
        for (m = 0, len1 = ref1.length; m < len1; m++) {
          nroad = ref1[m];
          if (road === nroad) {
            crossRoads.push(road);
          }
        }
      }
      if (crossRoads.length === 0) {
        return;
      }
      way = [];
      cross = crossRoads[randInt(0, crossRoads.length)];
      if (Math.random < .5) {
        ref2 = [from2, from1], from1 = ref2[0], from2 = ref2[1];
      }
      ref3 = from1.way;
      for (o = 0, len2 = ref3.length; o < len2; o++) {
        road = ref3[o];
        way.push(road);
        if (road === cross) {
          break;
        }
      }
      f = false;
      ref4 = from2.way;
      for (q = 0, len3 = ref4.length; q < len3; q++) {
        road = ref4[q];
        if (!f && road === cross) {
          f = true;
          continue;
        }
        if (f) {
          way.push(road);
        }
      }
      this.way = way;
      if ((this.eq(from1)) || (this.eq(from2))) {
        return this.way = [];
      }
    };

    Way.prototype.mutate = function(from, pref) {
      var f, flag, isFound, isLooped, k, len, len1, m, n, nway, postWay, ref, road, src, way;
      n = randInt(1, from.way.length - 3);
      way = from.way.slice(0, n);
      postWay = from.way.slice(n + 1);
      src = from.way[n].from;
      nway = [];
      isLooped = function() {
        var i, j, k, m, ref, ref1, ref2;
        for (i = k = 0, ref = nway.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
          for (j = m = ref1 = i + 1, ref2 = nway.length; ref1 <= ref2 ? m < ref2 : m > ref2; j = ref1 <= ref2 ? ++m : --m) {
            if (nway[i].from === nway[j].to) {
              return true;
            }
          }
        }
        return false;
      };
      isFound = function() {
        var end, k, len, road;
        if (nway.length < 2) {
          return false;
        }
        end = nway[nway.length - 1];
        for (k = 0, len = postWay.length; k < len; k++) {
          road = postWay[k];
          if (road.from === end.to) {
            return true;
          }
        }
        return false;
      };
      f = function(r) {
        var k, len, ref, road;
        if (r === 0) {
          return false;
        }
        if (isFound()) {
          return true;
        }
        ref = nway[nway.length - 1].to.roads.mix();
        for (k = 0, len = ref.length; k < len; k++) {
          road = ref[k];
          nway.push(road);
          if (!isLooped()) {
            if (f(r - 1)) {
              return true;
            }
          }
          nway.pop();
        }
      };
      ref = src.roads.mix();
      for (k = 0, len = ref.length; k < len; k++) {
        road = ref[k];
        nway.push(road);
        if (f(pref)) {
          break;
        }
        nway.pop();
      }
      if (nway.length === 0) {
        return;
      }
      way = way.concat(nway);
      flag = false;
      for (m = 0, len1 = postWay.length; m < len1; m++) {
        road = postWay[m];
        if (road.from === nway[nway.length - 1].to) {
          flag = true;
        }
        if (flag) {
          way.push(road);
        }
      }
      this.way = way;
      if (this.eq(from)) {
        return this.way = [];
      }
    };

    Way.prototype.time = function() {
      var k, len, ref, ret, road;
      if (this._time != null) {
        return this._time;
      }
      ret = 0;
      ref = this.way;
      for (k = 0, len = ref.length; k < len; k++) {
        road = ref[k];
        ret += road.time();
      }
      this._time = ret;
      return ret;
    };

    Way.prototype.draw = function() {
      var index, k, len, len1, m, ref, ref1, road, way;
      ctx.strokeStyle = "yellow";
      ctx.fillStyle = "white";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ref = this.way;
      for (index = k = 0, len = ref.length; k < len; index = ++k) {
        way = ref[index];
        ctx.moveTo(way.from.x, way.from.y);
        ctx.lineTo(way.to.x, way.to.y);
        if (params.drawNums) {
          ctx.fillText("" + index, way.to.x, way.to.y);
        }
      }
      ctx.stroke();
      if (params.drawLines) {
        ctx.lineWidth = 2;
        ref1 = this.way;
        for (m = 0, len1 = ref1.length; m < len1; m++) {
          road = ref1[m];
          ctx.beginPath();
          ctx.strokeStyle = "rgb(" + (255 - road.speed) + "," + road.speed + ",0)";
          ctx.moveTo(road.from.x, road.from.y);
          ctx.lineTo(road.to.x, road.to.y);
          ctx.stroke();
        }
      }
      return ctx.lineWidth = 1;
    };

    Way.prototype.isValid = function() {
      var curr, k, len, ref, results, road;
      curr = this.way[0];
      ref = this.way.slice(1);
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        road = ref[k];
        if (road.from !== curr.to) {
          throw new Error("lol");
        }
        results.push(curr = road);
      }
      return results;
    };

    Way.prototype.eq = function(other) {
      var i, k, ref;
      if (this.way.length !== other.way.length) {
        return false;
      }
      for (i = k = 0, ref = this.way.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        if (this.way[i] !== other.way[i]) {
          return false;
        }
      }
      return true;
    };

    return Way;

  })();

  Alg = (function() {
    function Alg(type) {
      var i, k;
      if (params.greenway) {
        this.map = new Map(40, 30, "greenway");
      } else {
        this.map = new Map(40, 30);
      }
      this.generation = 0;
      this.population = [];
      for (i = k = 130; k <= 255; i = k += 1) {
        this.population.push(new Way("rand", this.map, i / 255));
      }
      this.current = 0;
      this.kill = 40;
      this.mutate = 100;
      this.addmutants = 1;
      this.draw();
    }

    Alg.prototype.draw = function() {
      if (this.current >= this.population.length) {
        this.current = 0;
      }
      if (this.current < 0) {
        this.current = this.population.length - 1;
      }
      this.map.draw();
      document.getElementById("gen").innerHTML = "Поколение:" + this.generation + "<br> Размер популяции:" + this.population.length + "<br> Текущая особь:" + this.current + "<br> Время особи:" + ((Math.floor(this.population[this.current].time() * 100)) / 100);
      return this.population[this.current].draw();
    };

    Alg.prototype.killSome = function() {
      if (this.population.length <= this.kill) {
        return;
      }
      return this.population = this.population.slice(0, this.kill);
    };

    Alg.prototype.crossSome = function() {
      var crossed, i1, i2, k, l, len, len1, m, ref, ref1, way1, way2;
      l = this.population.length;
      ref = this.population;
      for (i1 = k = 0, len = ref.length; k < len; i1 = ++k) {
        way1 = ref[i1];
        ref1 = this.population;
        for (i2 = m = 0, len1 = ref1.length; m < len1; i2 = ++m) {
          way2 = ref1[i2];
          if (!(way1 !== way2 && Math.random() < (2 * l - i1 - i2) / l / 2)) {
            continue;
          }
          crossed = new Way("cross", this.map, way1, way2);
          if (crossed.way.length !== 0) {
            this.population.push(crossed);
          }
        }
      }
    };

    Alg.prototype.mutateSome = function() {
      var mutated, results, way;
      results = [];
      while (this.population.length <= this.mutate) {
        results.push((function() {
          var k, len, ref, results1;
          ref = this.population;
          results1 = [];
          for (k = 0, len = ref.length; k < len; k++) {
            way = ref[k];
            mutated = new Way("mutate", this.map, way, randInt(4, 30));
            if (mutated.way.length !== 0) {
              results1.push(this.population.push(mutated));
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    Alg.prototype.addMutants = function() {
      var i, k, ref, results;
      results = [];
      for (i = k = 0, ref = this.addmutants; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        results.push(this.population.unshift(new Way("rand", this.map, randInt(130, 255))));
      }
      return results;
    };

    Alg.prototype.sort = function() {
      if (params.findLongest) {
        return this.population.sort(function(a, b) {
          return b.time() - a.time();
        });
      } else {
        return this.population.sort(function(a, b) {
          return a.time() - b.time();
        });
      }
    };

    Alg.prototype.tick = function() {
      this.generation++;
      this.sort();
      this.killSome();
      this.addMutants();
      this.crossSome();
      this.mutateSome();
      return this.sort();
    };

    return Alg;

  })();

  alg = new Alg;

  timer = null;

  document.getElementById("go").addEventListener("click", function(e) {
    timer = timer == null ? setInterval(function() {
      alg.tick();
      return alg.draw();
    }, 250) : (clearInterval(timer), null);
  });

  document.getElementById("regen").addEventListener("click", function(e) {
    return alg = new Alg;
  });

  document.getElementById("+").addEventListener("click", function(e) {
    alg.current++;
    return alg.draw();
  });

  document.getElementById("-").addEventListener("click", function(e) {
    alg.current--;
    return alg.draw();
  });

  document.getElementById("colors").addEventListener("change", function(e) {
    params.drawLines = e.target.checked;
    return alg.draw();
  });

  document.getElementById("numbers").addEventListener("change", function(e) {
    params.drawNums = e.target.checked;
    return alg.draw();
  });

  document.getElementById("long").addEventListener("change", function(e) {
    params.findLongest = e.target.checked;
    return alg.draw();
  });

  document.getElementById("fast").addEventListener("change", function(e) {
    params.greenway = e.target.checked;
    alg = new Alg;
    return alg.draw();
  });

  document.getElementById("kill").addEventListener("change", function(e) {
    var val;
    val = +e.target.value;
    if (!isNaN(val)) {
      return alg.kill = val;
    } else {
      return e.target.value = alg.kill;
    }
  });

  document.getElementById("addmutants").addEventListener("change", function(e) {
    var val;
    val = +e.target.value;
    if (!isNaN(val)) {
      return alg.addmutants = val;
    } else {
      return e.target.value = alg.addmutants;
    }
  });

  document.getElementById("mutate").addEventListener("change", function(e) {
    var val;
    val = +e.target.value;
    if (!isNaN(val)) {
      return alg.mutate = val;
    } else {
      return e.target.value = alg.mutate;
    }
  });

}).call(this);
